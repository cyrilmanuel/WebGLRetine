<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="../FabioManuelDaMotaMarques/code/css/stylesheet.css">
		<script src="fileOther/commonFunctions.js">
		</script>
		<script src="fileOther/gl-matrix-min.js">
		</script>
		<script src="fileOther/webglTools.js">
		</script>
		
		<!-- Vertx shader -->
		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			
			varying vec2 vTextureCoord;
			
			void main(void) 
				{
				vTextureCoord = aTextureCoord;
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				}
		</script>
		
		<!-- Fragment shader - rendu sur écran -->
		<script id="shader-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
			
			uniform sampler2D uColorTexture;
			
			varying vec2 vTextureCoord;
						
			void main(void) 
				{
				vec2 mapCoord = vec2(vTextureCoord.s, vTextureCoord.t);
				vec4 texelColor = texture2D(uColorTexture, mapCoord);
				gl_FragColor = texelColor.rgba;	
				}
		</script>
		
		<!-- Fragment shader - Filtre passe-bas - rendu sur texture -->
		<script id="shader-lowPassFilter-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
			
			uniform sampler2D uColorTexture;			
			
			varying vec2 vTextureCoord;
			
			const float d = 1./1024.;
			
			uniform int uMode;
			
			void main(void)
				{
				if(uMode == 1 || uMode == 2)
					{
					vec2 cf0 = vec2(vTextureCoord.s-d, vTextureCoord.t-d);
					vec2 cf1 = vec2(vTextureCoord.s, vTextureCoord.t-d);
					vec2 cf2 = vec2(vTextureCoord.s+d, vTextureCoord.t-d);
					
					vec2 cf3 = vec2(vTextureCoord.s-d, vTextureCoord.t);
					vec2 cf4 = vec2(vTextureCoord.s, vTextureCoord.t);
					vec2 cf5 = vec2(vTextureCoord.s+d, vTextureCoord.t);
					
					vec2 cf6 = vec2(vTextureCoord.s-d, vTextureCoord.t+d);
					vec2 cf7 = vec2(vTextureCoord.s, vTextureCoord.t+d);
					vec2 cf8 = vec2(vTextureCoord.s+d, vTextureCoord.t+d);
					
					vec4 txlClr0 = texture2D(uColorTexture, cf0);
					vec4 txlClr1 = texture2D(uColorTexture, cf1);
					vec4 txlClr2 = texture2D(uColorTexture, cf2);
					vec4 txlClr3 = texture2D(uColorTexture, cf3);
					vec4 txlClr4 = texture2D(uColorTexture, cf4);
					vec4 txlClr5 = texture2D(uColorTexture, cf5);
					vec4 txlClr6 = texture2D(uColorTexture, cf6);
					vec4 txlClr7 = texture2D(uColorTexture, cf7);
					vec4 txlClr8 = texture2D(uColorTexture, cf8);
					
					//floutage de chaque fragment par une moyenne avec les voisns
					//				| 1 1 1 |
					//				| 1 1 1 |	/	9
					//				| 1 1 1 |
					vec4 newClr = (txlClr0 + txlClr1 + txlClr2 + txlClr3
									+ txlClr4 + txlClr5 + txlClr6 + txlClr7 + txlClr8)/9.0;		
									
					gl_FragColor = vec4(newClr.rgb, 1.0);
					}
				}
		</script>
		
		<!-- Fragment shader - Filtre passe-haut - rendu sur texture -->
		<script id="shader-highPassFilter-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
			
			uniform sampler2D uColorTexture;			
			
			varying vec2 vTextureCoord;
			
			const float d = 1./1024.;
			
			uniform int uMode;
			
			void main(void)
				{
				if(uMode == 4)
					{
					vec2 cf1 = vec2(vTextureCoord.s, vTextureCoord.t-d);
					
					vec2 cf3 = vec2(vTextureCoord.s-d, vTextureCoord.t);
					vec2 cf4 = vec2(vTextureCoord.s, vTextureCoord.t);
					vec2 cf5 = vec2(vTextureCoord.s+d, vTextureCoord.t);
					
					vec2 cf7 = vec2(vTextureCoord.s, vTextureCoord.t+d);
					
					vec4 txlClr1 = texture2D(uColorTexture, cf1);
					vec4 txlClr3 = texture2D(uColorTexture, cf3);
					vec4 txlClr4 = texture2D(uColorTexture, cf4);
					vec4 txlClr5 = texture2D(uColorTexture, cf5);
					vec4 txlClr7 = texture2D(uColorTexture, cf7);
					
					//rehaussement des contours avec la matrice suivante
					//				| 0 -1  0|
					//				|-1  5 -1|
					//				| 0 -1  0|
					vec4 newClr = ( - txlClr1  - txlClr3 + txlClr4 + txlClr4 + txlClr4
									+ txlClr4 + txlClr4 - txlClr5  - txlClr7);		
									
					gl_FragColor = vec4(newClr.rgb, 1.0);
					}
				}
		</script>
		
		<!-- Fragment shader - differentiation - rendu sur texture -->
		<script id="shader-differentiation-fs" type="x-shader/x-fragment">
			#ifdef GL_ES
				precision highp float;
			#endif
			
			uniform sampler2D uColorTexture0;
			uniform sampler2D uColorTexture1;
			
			varying vec2 vTextureCoord;
			
			uniform int uMode;
						
			void main(void)
				{
				if(uMode == 3 || uMode ==5)
					{
					vec2 cf1 = vec2(vTextureCoord.s, vTextureCoord.t);
					
					vec4 txlClr1 = texture2D(uColorTexture0, cf1);
					vec4 txlClr2 = texture2D(uColorTexture1, cf1);
					
					vec4 newClr = (txlClr1 - txlClr2);
					
					gl_FragColor = vec4(newClr.rgb, 1.0);
					}
				}
		</script>
		
		<script>
			//Tableaux avec les sommets(vertices), indices et coordonées de texture
			var vertices = [];
			var indices = [];
			var textCoords =[];
			
			//Buffer avec les sommets(vertices), indices et coordonées de texture
			var vertexBuffer = null;
			var indexBuffer = null;
			var textCoordsBuffer = null;
			
			//Matrices modelViewMatrix et projectionMatrix
			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
			
			const TEXTURE_SIZE = 1024;	
			
			//Constantes qui correspondents à l'indice du tableau de shaders
			const LOW_PASS_FILTERS_TEXTURE_RENDER_MODE = 0;
			const HIGH_PASS_FILTERS_TEXTURE_RENDER_MODE = 1;
			const DIFFERENTIATION_TEXTURE_RENDER_MODE = 2;
			const SCREEN_RENDERING_MODE = 3;

			//Variables pour le nombre d'iterations dans une couche
			var nbOfIterationInLayer2 = 1;
			var nbOfIterationInLayer4 = 1;
			
			//Buffers nécessaires pour faire les rndus sur texture
			var rttFramebuffer = [];
		    var rttTexture = [];
			var renderbuffer = [];
			var lastBufferIndexTreated;
			
			//gestion shaders et textures multiples
			var shaders = [];
			var currentShader = null;
			//var texColorTab = [];
			
			//Flags
			var currentLayerFlag = 0;
			const LAYER_0 = 0;
			const LAYER_1 = 1;
			const LAYER_2 = 2;
			const LAYER_3 = 3;
			const LAYER_4 = 4;
			const LAYER_5 = 5;
			
			//Flux WebCam
			var videoElement;
			var videoTexture;
			var intervalID;
			
			{
			function hasGetUserMedia() 
				{
				return !!(navigator.getUserMedia || navigator.webkitGetUserMedia ||
					navigator.mozGetUserMedia || navigator.msGetUserMedia);
				}

			if (hasGetUserMedia()) 
				{
				// On est bon, média trouvé
				}
			else 
				{
				alert('getUserMedia() is not supported in your browser');
				}
			
			var errorCallback = function(e) {
				console.log('Reeeejected!', e);
				};
				
			navigator.getUserMedia  = navigator.getUserMedia ||
									  navigator.webkitGetUserMedia ||
									  navigator.mozGetUserMedia ||
									  navigator.msGetUserMedia;

			
			navigator.getUserMedia({video: true}, function(localMediaStream) 
				{
				videoElement = document.querySelector('video');
				videoElement.src = window.URL.createObjectURL(localMediaStream);
				
				if (navigator.getUserMedia) 
					{
					navigator.getUserMedia({audio: true, video: true}, function(stream) 
						{
						videoElement.src = stream;
						}, onFailSoHard);
					} 
				else if (navigator.webkitGetUserMedia)
					{
					navigator.webkitGetUserMedia('audio, video', function(stream) 
						{
						videoElement.src = window.webkitURL.createObjectURL(stream);
						}, onFailSoHard);
					} 
				else 
					{
					videoElement.src = 'somevideo.webm'; // fallback.
					}

				// Note: onloadedmetadata doesn't fire in Chrome when using it with getUserMedia.
				// See crbug.com/110938.
				videoElement.onloadedmetadata = function(e) 
					{
					// Ready to go. Do some stuff.
					};
				}, errorCallback);
			}
			
			function initWebGL()
				{
				glContext = getGLContext('WebGLCanvas');
				videoElement = document.getElementById("video");
				
				initBuffers();
				
				initShaders([{vertex:"shader-vs", fragment:"shader-lowPassFilter-fs"},
							 {vertex:"shader-vs", fragment:"shader-highPassFilter-fs"},
							 {vertex:"shader-vs", fragment:"shader-differentiation-fs"},
							 {vertex:"shader-vs", fragment:"shader-fs"}]);
				
				initTexture();
				//initTextureWithImage( "img/Lenna.png", videoTexture);
				
				initTextureFramebuffer(0);
				initTextureFramebuffer(1);
				initTextureFramebuffer(2);
				initTextureFramebuffer(3);
				initTextureFramebuffer(4);
				initTextureFramebuffer(5);
				initTextureFramebuffer(6);
				initTextureFramebuffer(7);
				
				videoElement.addEventListener("canplaythrough", startVideo, true);
				videoElement.addEventListener("ended", videoDone, true);
				
				document.getElementById("layer0").checked = "checked";
				setLayer();
				setNbOfIterationsInLayer2();
				setNbOfIterationsInLayer4();
				
				setInterval(renderLoop, 5);
				//renderLoop();
				}
							
			function initBuffers()
				{
				console.log("initBuffers()");
				vertices = [ -1.0, -1.0, 0.0,
							  1.0, -1.0, 0.0,
							 -1.0,  1.0, 0.0,
							  1.0,  1.0, 0.0 ];
				indices = [ 0, 1, 2, 3];
				textCoords = [  0.0, 0.0,
								1.0, 0.0,
								0.0, 1.0,
								1.0, 1.0 ];
				vertexBuffer     = getArrayBufferWithArray(vertices);
				indexBuffer      = getIndexBufferWithIndices(indices);
				textCoordsBuffer = getArrayBufferWithArray(textCoords);
				}
			
			function initShaders(shadersDataArray)
				{
				console.log("initShaders()");
				
				for (var i = 0; i < shadersDataArray.length; i++)
					{
					var aShader = shadersDataArray[i];
					var fgShader = getShader(glContext, aShader.fragment);
				    var vxShader = getShader(glContext, aShader.vertex);
				    var newShader = glContext.createProgram();
				    
					glContext.attachShader(newShader, vxShader);
				    glContext.attachShader(newShader, fgShader);
				    glContext.linkProgram(newShader);
				   
				   if (!glContext.getProgramParameter(newShader, glContext.LINK_STATUS))
						{
				        alert("Could not initialise shader: "+aShader.fragment+" / "+aShader.vertex);
						}
					else
						{
					    shaders.push(newShader);
						}
					}
			    initShaderParameters();
				}
			
			function initShaderParameters()
				{
				console.log("initShaderParameters()");
				
				//Filtres pass-bas -> rendu sur texture
				currentShader = shaders[LOW_PASS_FILTERS_TEXTURE_RENDER_MODE];
				glContext.useProgram(currentShader);
				
				currentShader.vertexPositionAttribute = glContext.getAttribLocation(currentShader, "aVertexPosition");
				glContext.enableVertexAttribArray(currentShader.vertexPositionAttribute);
				
				currentShader.textureCoordsAttribute = glContext.getAttribLocation(currentShader, "aTextureCoord");
				glContext.enableVertexAttribArray(currentShader.textureCoordsAttribute);
				
				currentShader.pMatrixUniform = glContext.getUniformLocation(currentShader, 'uPMatrix');
				currentShader.mvMatrixUniform = glContext.getUniformLocation(currentShader, 'uMVMatrix');
				currentShader.colorTextureUniform = glContext.getUniformLocation(currentShader, "uColorTexture");
				currentShader.modeUniform = glContext.getUniformLocation(prg, "uMode");
				
				//Filtres pass-haut -> rendu sur texture
				currentShader = shaders[HIGH_PASS_FILTERS_TEXTURE_RENDER_MODE];
				glContext.useProgram(currentShader);
				
				currentShader.vertexPositionAttribute = glContext.getAttribLocation(currentShader, "aVertexPosition");
				glContext.enableVertexAttribArray(currentShader.vertexPositionAttribute);
				
				currentShader.textureCoordsAttribute = glContext.getAttribLocation(currentShader, "aTextureCoord");
				glContext.enableVertexAttribArray(currentShader.textureCoordsAttribute);
				
				currentShader.pMatrixUniform = glContext.getUniformLocation(currentShader, 'uPMatrix');
				currentShader.mvMatrixUniform = glContext.getUniformLocation(currentShader, 'uMVMatrix');
				currentShader.colorTextureUniform = glContext.getUniformLocation(currentShader, "uColorTexture");
				currentShader.modeUniform = glContext.getUniformLocation(prg, "uMode");
				
				//Différenciation -> rendu sur texture
				currentShader = shaders[DIFFERENTIATION_TEXTURE_RENDER_MODE];
				glContext.useProgram(currentShader);
				
				currentShader.vertexPositionAttribute = glContext.getAttribLocation(currentShader, "aVertexPosition");
				glContext.enableVertexAttribArray(currentShader.vertexPositionAttribute);
				
				currentShader.textureCoordsAttribute = glContext.getAttribLocation(currentShader, "aTextureCoord");
				glContext.enableVertexAttribArray(currentShader.textureCoordsAttribute);
				
				currentShader.pMatrixUniform = glContext.getUniformLocation(currentShader, 'uPMatrix');
				currentShader.mvMatrixUniform = glContext.getUniformLocation(currentShader, 'uMVMatrix');
				currentShader.colorTextureUniform = glContext.getUniformLocation(currentShader, "uColorTexture0");
				currentShader.colorTextureUniform = glContext.getUniformLocation(currentShader, "uColorTexture1");
				currentShader.modeUniform = glContext.getUniformLocation(prg, "uMode");
				
				//Rendu sur écran
				currentShader = shaders[SCREEN_RENDERING_MODE];
				glContext.useProgram(currentShader);
				
				currentShader.vertexPositionAttribute = glContext.getAttribLocation(currentShader, "aVertexPosition");
			    glContext.enableVertexAttribArray(currentShader.vertexPositionAttribute);
				
			    currentShader.vertexNormalAttribute = glContext.getAttribLocation(currentShader, "aTextureCoord");
			    glContext.enableVertexAttribArray(currentShader.vertexNormalAttribute);
				
			    currentShader.pMatrixUniform = glContext.getUniformLocation(currentShader, 'uPMatrix');
			    currentShader.mvMatrixUniform = glContext.getUniformLocation(currentShader, 'uMVMatrix');
			    currentShader.colorTextureUniform = glContext.getUniformLocation(currentShader, "uColorTexture");
				}
			
			function initTexture()
				{
				videoTexture = glContext.createTexture();
				
				videoTexture.image = new Image();
				videoTexture.image.onload = function() 
					{
					handleLoadedTexture(videoTexture)
					}
				videoTexture.image.src = videoElement.src;
				}
			
			function handleLoadedTexture(texture) 
				{
				try 
					{
					glContext.pixelStorei(glContext.UNPACK_FLIP_Y_WEBGL, true);
					glContext.bindTexture(glContext.TEXTURE_2D, texture);
					glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, glContext.RGBA, glContext.UNSIGNED_BYTE, texture.image);
					glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
					glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
					glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
					glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
					glContext.bindTexture(glContext.TEXTURE_2D, null);
					} 
				catch (e) 
					{
					console.log(e.message);
					}
				}
			
			function insertVideo(video)
				{
				videoTexture.image = video;
				handleLoadedTexture(videoTexture)
				}

				
			function startVideo()
				{
				videoElement.play();
				videoElement.muted = true;
				intervalID = setInterval(drawScene, 100);
				}

			function videoDone()
				{
				clearInterval(intervalID);
				}
			
			function initTextureFramebuffer(index)
				{
				//console.log("initTextureFramebuffer(), index = ", index);
				
				//Allocation mémoire pour le buffer de taille(textureSize, textureSize)
		        rttFramebuffer[index] = glContext.createFramebuffer();
		        glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[index]);
		        rttFramebuffer[index].width = TEXTURE_SIZE;
		        rttFramebuffer[index].height = TEXTURE_SIZE;
				
				//Création de texture vide et stocké dans le buffer
		        rttTexture[index] = glContext.createTexture();
		        glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[index]);
		        glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
				glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
		        glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, rttFramebuffer[index].width, 
					rttFramebuffer[index].height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
		        
				//Création de buffer de rendu
				renderbuffer = glContext.createRenderbuffer();
		        glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
		        glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16, 
					rttFramebuffer[index].width, rttFramebuffer[index].height);
		        
				//buffer de rendu alloué et stocké dans la texture créée
				glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0, 
					glContext.TEXTURE_2D, rttTexture[index], 0);
		        glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT, 
					glContext.RENDERBUFFER, renderbuffer);
		        
				glContext.bindTexture(glContext.TEXTURE_2D, null);
		        glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
		        glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
				}
			
			function renderToTexture()
				{
				//console.log("renderToTexture()");
				
				//glContext.clearColor(0.9, 0.9, 0.9, 1.0);
				//glContext.enable(glContext.DEPTH_TEST);
				//glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				glContext.viewport(0, 0, rttFramebuffer[LAYER_0].width,
						rttFramebuffer[LAYER_0].height);
				
				currentShader = shaders[LOW_PASS_FILTERS_TEXTURE_RENDER_MODE];
				glContext.activeTexture(glContext.TEXTURE0);
				glContext.useProgram(currentShader);
				//console.log("current shader = LOW_PASS_FILTERS_TEXTURE_RENDER_MODE");
				
				mat4.identity(pMatrix);
				glContext.uniformMatrix4fv(currentShader.pMatrixUniform, false, pMatrix);
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(currentShader.mvMatrixUniform, false, mvMatrix);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
				glContext.vertexAttribPointer(currentShader.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				
				glContext.bindTexture(glContext.TEXTURE_2D, videoTexture);
				glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
		        glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
		        glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[0]);
				}
			
			function renderToScreen(indexToShow)
				{
				console.log("renderToScreen(), currentLayerFlag = ", currentLayerFlag);
				glContext.clearColor(0.0, 0.0, 0.0, 1.0);
				glContext.enable(glContext.DEPTH_TEST);
				glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
				glContext.viewport(0, 0, c_width, c_height);
				
				currentShader = shaders[SCREEN_RENDERING_MODE];
				glContext.activeTexture(glContext.TEXTURE0);
				glContext.useProgram(currentShader);
				//console.log("current shader = SCREEN_RENDERING_MODE");
				
				mat4.identity(pMatrix);
				mat4.ortho(pMatrix, 0.0, 1.0, 0.0, 1.0, -1.0, 1.0);
				glContext.uniformMatrix4fv(currentShader.pMatrixUniform, false, pMatrix);
				
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(currentShader.mvMatrixUniform, false, mvMatrix);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
				glContext.vertexAttribPointer(currentShader.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				
				
				if(currentLayerFlag == LAYER_0)
					{
					glContext.bindTexture(glContext.TEXTURE_2D,  videoTexture);
					glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
					glContext.uniform1i(currentShader.colorTextureUniform, 0);
					}
				else
					{
					glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[indexToShow]);
					glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
					glContext.uniform1i(currentShader.colorTextureUniform, 0);
					}
				}
			
			function blur(layerNumber, filteringNumber)
				{
				console.log("blur() on layer ", layerNumber);
				currentShader = shaders[LOW_PASS_FILTERS_TEXTURE_RENDER_MODE];
				glContext.activeTexture(glContext.TEXTURE0);
				glContext.useProgram(currentShader);
								
				mat4.identity(pMatrix);
				glContext.uniformMatrix4fv(currentShader.pMatrixUniform, false, pMatrix);
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(currentShader.mvMatrixUniform, false, mvMatrix);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
				glContext.vertexAttribPointer(currentShader.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				
				var i;
				for(i=0; i<filteringNumber; i++)
					{
					if(i == 0 && layerNumber == 1)
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[0]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[1]);
						}
					else if(i == 0)
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[1]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[2]);
						}
					else if((i % 2) == 1)
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[2]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[3]);
						}
					else
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[3]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[2]);
						}
					}
				i = i - 1;
				return (i % 2) == 1 ? 3 : 2 ;
				}
			
			function contourDetection(filteringNumber)
				{
				currentShader = shaders[HIGH_PASS_FILTERS_TEXTURE_RENDER_MODE];
				glContext.activeTexture(glContext.TEXTURE0);
				glContext.useProgram(currentShader);
				console.log("current shader = HIGH_PASS_FILTERS_TEXTURE_RENDER_MODE");
								
				mat4.identity(pMatrix);
				glContext.uniformMatrix4fv(currentShader.pMatrixUniform, false, pMatrix);
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(currentShader.mvMatrixUniform, false, mvMatrix);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
				glContext.vertexAttribPointer(currentShader.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				
				for(var i=0; i<filteringNumber; i++)
					{
					if(i == 0)
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[4]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[5]);
						}
					else if((i % 2) == 1)
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[5]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[6]);
						}
					else
						{
						glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[6]);
						glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
						glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[5]);
						}
					}
				i = i - 1;
				return (i % 2) == 1 ? 6 : 5 ;
				}
			
			function differnciation(layerNumber, lastPreviousIndex)
				{
				currentShader = shaders[DIFFERENTIATION_TEXTURE_RENDER_MODE];
				glContext.useProgram(currentShader);
				console.log("current shader = DIFFERENTIATION_TEXTURE_RENDER_MODE");
				
				mat4.identity(pMatrix);
				glContext.uniformMatrix4fv(currentShader.pMatrixUniform, false, pMatrix);
				mat4.identity(mvMatrix);
				glContext.uniformMatrix4fv(currentShader.mvMatrixUniform, false, mvMatrix);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, vertexBuffer);
				glContext.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ARRAY_BUFFER, textCoordsBuffer);
				glContext.vertexAttribPointer(currentShader.textureCoordsAttribute, 2, glContext.FLOAT, false, 0, 0);
				
				glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, indexBuffer);
				glContext.drawElements(glContext.TRIANGLE_STRIP, indices.length, glContext.UNSIGNED_SHORT,0);
				
				var u_image0Location = glContext.getUniformLocation(currentShader, "uColorTexture0");
				var u_image1Location = glContext.getUniformLocation(currentShader, "uColorTexture1");
				
				glContext.uniform1i(u_image0Location, 0);
				glContext.uniform1i(u_image1Location, 1);
				
				glContext.uniform1i(currentShader.modeUniform, currentLayerFlag);
				if(layerNumber == LAYER_3)
					{
					
					glContext.activeTexture(glContext.TEXTURE0);
					glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[lastPreviousIndex]);
					glContext.activeTexture(glContext.TEXTURE1);
					glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[1]);
					glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
					glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[4]);
					}
				else
					{
					glContext.activeTexture(glContext.TEXTURE0);
					glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[4]);
					glContext.activeTexture(glContext.TEXTURE1);
					glContext.bindTexture(glContext.TEXTURE_2D, rttTexture[lastPreviousIndex]);
					glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
					glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[7]);
					}
				}
				
			function drawScene()
				{
				console.log("currentLayerFlag = ", currentLayerFlag);
				insertVideo(document.querySelector("video"));
				glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[0]);
				renderToTexture();				
				
				/*
				if(currentLayerFlag >= LAYER_1)
					{
					
					glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[1]);
					blur(LAYER_1, 1);
					
					if(currentLayerFlag >= LAYER_2)
						{
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[1]);
						lastBufferIndexTreated = blur(LAYER_2, nbOfIterationInLayer2);
						
						if(currentLayerFlag >= LAYER_3)
							{
							
							glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[lastBufferIndexTreated]);
							differnciation(LAYER_3, lastBufferIndexTreated);
							
							if(currentLayerFlag >= LAYER_4)
								{
								glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[4];
								lastBufferIndexTreated = contourDetection(nbOfIterationInLayer4);
								
								if(currentLayerFlag >= LAYER_5)
									{
									glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFramebuffer[4]);
									differnciation(LAYER_5, lastBufferIndexTreated);
									
											//Affiche couche 5
									glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
									renderToScreen(7)
									}
								else	//Affiche couche 4
									{
									glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
									renderToScreen(lastBufferIndexTreated);
									}
								}
							else	//Affiche couche 3
								{
								glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
								renderToScreen(4);
								}
							
							}
						else 	//Affiche couche  2
							{
							glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
							renderToScreen(lastBufferIndexTreated);
							}
						}
						
					else	//Affiche couche 1
						{
						glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
						renderToScreen(1);
						}
					}
				else	//Affiche couche 0
					{
				*/	
					glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
					renderToScreen(0);
				//	}
				}
			
			function setNbOfIterationsInLayer2()
				{
				nbOfIterationInLayer2 = document.getElementById("sliderLayer2").value;
				document.getElementById("nbOfIterationsInLayer2").innerHTML = "Nombre de filtres passe-bas = " + nbOfIterationInLayer2;
				}
			
			function setNbOfIterationsInLayer4()
				{
				nbOfIterationInLayer4 = document.getElementById("sliderLayer4").value;
				document.getElementById("nbOfIterationsInLayer4").innerHTML = "Nombre de filtres passe-haut = " + nbOfIterationInLayer4;
				}
			
			function setLayer()
				{
				if(layer0.checked)
					{
					currentLayerFlag = LAYER_0;
					document.getElementById("layerText").innerHTML = 
					"La couche (0) n'est pas réelement une couche rétinienne. Celle-ci montre l'input original sans traitement";
					}
				else if(layer1.checked)
					{
					currentLayerFlag = LAYER_1;
					document.getElementById("layerText").innerHTML = 
					"La couoche (1) des cônes filtre les basses fréquences (floutage)";
					}
				else if(layer2.checked)
					{
					currentLayerFlag = LAYER_2;
					document.getElementById("layerText").innerHTML = 
					"La couche (2) des horizontales filtre les basses fréquences n-fois (floutage)";
					}
				else if(layer3.checked)
					{
					currentLayerFlag = LAYER_3;
					document.getElementById("layerText").innerHTML = 
					"La couche (3) des bipolaires fait la différence entre les signaux reçus de la couche des horizontales et ceux des cônes";
					}
				else if(layer4.checked)
					{
					currentLayerFlag = LAYER_4;
					document.getElementById("layerText").innerHTML = 
					"La couche (4) des amacrines filtre les hautes fréquences n-fois (detection des contours)";
					}
				else if(layer5.checked)
					{
					currentLayerFlag = LAYER_5;
					document.getElementById("layerText").innerHTML = 
					"La couche (5) des ganglionaires fait la différence entre les bipolaires et les amacrines";
					}
				renderLoop();
				}

				
		</script>
	</head>
	<body onload="initWebGL()">
		<header>
			<h1>Retina Simulation</h1>
		</header>
		
		<div id="canvasDiv">
			<canvas id="WebGLCanvas" width="500" height="500">
				HTML5 n'est pas supporté
			</canvas>
		</div>
		
		<video id="video"  width="500" height="500" autoplay></video>
		
		<div id="inputDiv">
			<table>
				<tbody>
					<form>
						<th>
							Choix de la couche à visionner
						</th>
						<tr>
							<td>
								<label for="layer0">Couche (0) sans traitement</label>
								<input id="layer0" type="radio" name="layerGroup" value="0" onchange="setLayer()" checked="checked">
							</td>	
						</tr>
						<tr>
							<td>
								<label for="layer1">Couche (1) des cônes</label>
								<input id="layer1" type="radio" name="layerGroup" value="1" onchange="setLayer()">				
							</td>
						</tr>
						<tr>
							<td>
								<label for="layer2">Couche (2) des horizontales</label>
								<input id="layer2" type="radio" name="layerGroup" value="2" onchange="setLayer()">	
								
								<br/>
								
								<span>0</span>
								<input id="sliderLayer2" type="range" min="0" max="100" value="10" step="1" onchange ="setNbOfIterationsInLayer2()"></input>
								<span>100</span><br/>
								<span id="nbOfIterationsInLayer2">Nombre de filtres passe-bas = 10</span>
								
							</td>
						</tr>
						<tr>
							<td>
								<label for="layer3">Couche (3) des bipolaires</label>
								<input id="layer3" type="radio" name="layerGroup" value="3" onchange="setLayer()">					
							</td>
						</tr>
						<tr>
							<td>
								<label for="layer4">Couche (4) des amacrines</label>
								<input id="layer4" type="radio" name="layerGroup" value="4" onchange="setLayer()">	

								<br/>
								
								<span>0</span>
								<input id="sliderLayer4" type="range" min="0" max="100" value="10" step="1" onchange ="setNbOfIterationsInLayer4()"></input>
								<span>100</span><br/>
								<span id="nbOfIterationsInLayer4">Nombre de filtres passe-haut = 10</span>
							</td>
						</tr>						
						<tr>
							<td>
								<label for="layer5">Couche (5) des ganglionaires</label>
								<input id="layer5" type="radio" name="layerGroup" value="5" onchange="setLayer()">					
							</td>
						</tr>
					</form>
				</tbody>
			</table>
		</div>
		
		<div id="explanationDiv">
			<p id="layerText">La couche 0 n'est pas réelement une couche rétinienne. Celle-ci montre l'input original sans traitement</p>
		</div>
		
	</body>
</html>