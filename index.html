<!DOCTYPE html>
<!-- saved from url=(0052)http://webgl3d.info/ex/ch03_eg01_SingleTriangle.html -->
<html lang="fr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <link rel="stylesheet" href="fileOther/stylesheet.css">
    <script src="fileOther/commonFunctions.js">
    </script>
    <script src="fileOther/gl-matrix-min.js">
    </script>
    <script src="fileOther/webglTools.js">
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aColor;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec4 vColor;
        varying vec2 vTexCoord;
        void main(void) {
          vColor = aColor;
          vTexCoord = (aVertexPosition.xy + 1.0) / 2.0;
          gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }


    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
        #ifdef GL_ES
          precision highp float;
        #endif
        varying vec4 vColor;
        uniform sampler2D uSampler;
        uniform int uSamplerNumber;
        varying vec2 vTexCoord;
        void main(void) {
          if(uSamplerNumber == 1)
          {
            vec4 color = texture2D(uSampler, vTexCoord);
             color += vec4(0.0, 0.0, 0.5, 0.0);
            gl_FragColor = color;
          }
          else
          {
            if(uSamplerNumber == 2)
            {
                vec4 color = texture2D(uSampler, vTexCoord);
                color += vec4(0.0, 0.5, 0.0, 0.0);
                gl_FragColor = color;
            }
            else
            {
              gl_FragColor = vColor;
            }
          }
        }


    </script>
    <script>

        // dessin des triangles
        var triangleVertexBuffer = null;
        var triangleIndexBuffer = null;
        var triangleColorBuffer = null;

        var indicesTriangle = [];
        var verticesTriangle = [];
        var colorsTriangle = [];

        // dessin du carré pour le rendu. carré qui prend le canevas
        var squareVertexBuffer = null;
        var squareIndexBuffer = null;
        var squareColorBuffer = null;

        var indicesSquareCanevas = [];
        var verticesSquareCanevas = [];
        var colorsSquareCanevas = [];

        // dessin du carré pour le rendu. carré qui prend le canevas
        var multiSquareVertexBuffer = [];
        var multiSquareIndexBuffer = [];
        var multiSquareColorBuffer = [];

        var indicesMultiSquareCanevas = [];
        var verticesMultiSquareCanevas = [];
        var colorsMultiSquareCanevas = [];

        var mvMatrix = mat4.create();
        var pMatrix = mat4.create();

        var rttFrameBufferTab = [];
        var rttTextureTab = [];

        var nombreFrameBuffer = 2;

        function initTextureFramebufferTab() {
            for (i = 0; i < nombreFrameBuffer; i++) {

                rttFrameBufferTab[i] = glContext.createFramebuffer();
                glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFrameBufferTab[i]);
                rttFrameBufferTab[i].width = 512;
                rttFrameBufferTab[i].height = 512;

                // espace pour la texture sur la cg (WEBTOOL textureWithImage)

                rttTextureTab[i] = glContext.createTexture();
                glContext.bindTexture(glContext.TEXTURE_2D,  rttTextureTab[i]);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.LINEAR);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR_MIPMAP_NEAREST);
                //glContext.generateMipmap(glContext.TEXTURE_2D);
                glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, rttFrameBufferTab[i].width, rttFrameBufferTab[i].height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);

                // mtn on a préparer un espace pour la texture qui est vide et de taille du rttFramebuffer. contiendra pour les couleurs, le canevas.

                // on va  définir le buffer de rendu
                var renderbuffer = glContext.createRenderbuffer();
                glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
                glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16,  rttFrameBufferTab[i].width,  rttFrameBufferTab[i].height);

                /*
                 * Nous attachons tout à la framebuffer actuelle (rappelez-vous, nous avons lié notre nouveau pour être le courant juste après sa création en haut de la fonction).
                 * Nous lui disons que l'espace du framebuffer pour les couleurs de rendu ( gl.COLOR_ATTACHMENT0 ) est notre texture, et que la mémoire qu'il doit utiliser pour
                 * obtenir des informations de profondeur ( gl.DEPTH_ATTACHMENT ) est le tampon de profondeur que nous venons de créer.
                 * */
                glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0, glContext.TEXTURE_2D, rttTextureTab[i], 0);
                glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT, glContext.RENDERBUFFER, renderbuffer);

                /*
                 * maintenant que tout est correctement créer est binder, on les remets a 0
                 * */
                glContext.bindTexture(glContext.TEXTURE_2D, null);
                glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
                glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
            }

        }

        function initShaderParameters(prg) {
            prg.vertexPositionAttribute = glContext.getAttribLocation(prg, "aVertexPosition");
            glContext.enableVertexAttribArray(prg.vertexPositionAttribute);
            prg.colorAttribute = glContext.getAttribLocation(prg, "aColor");
            glContext.enableVertexAttribArray(prg.colorAttribute);
            prg.pMatrixUniform = glContext.getUniformLocation(prg, 'uPMatrix');
            prg.mvMatrixUniform = glContext.getUniformLocation(prg, 'uMVMatrix');

            prg.samplerUniform = glContext.getUniformLocation(prg, "uSampler");
            prg.samplerNumberUniform = glContext.getUniformLocation(prg, "uSamplerNumber");
        }
        function initBuffers() {


            // partie pour les triangles de base

            // POS X Y Z
            verticesTriangle.push(-1.0, -1.0, 0.0);
            verticesTriangle.push(1.0, -1.0, 0.0);
            verticesTriangle.push(0.0, 1.0, 0.0);

            verticesTriangle.push(-1, 1.0, 0.0);
            verticesTriangle.push(1.0, 1.0, 0.0);
            verticesTriangle.push(0.0, -1.0, 0.0);


            // color R G B TRANSPARENCE
            colorsTriangle.push(0.0, 0.0, 0.0, 1.0);
            colorsTriangle.push(0.0, 0.0, 0.0, 1.0);
            colorsTriangle.push(0.0, 0.0, 0.0, 1.0);


            colorsTriangle.push(1.0, 1.0, 1.0, 1.0);
            colorsTriangle.push(1.0, 1.0, 1.0, 1.0);
            colorsTriangle.push(1.0, 1.0, 1.0, 1.0);

            indicesTriangle.push(0, 1, 2);
            indicesTriangle.push(3, 4, 5);


            triangleVertexBuffer = getVertexBufferWithVertices(verticesTriangle);
            triangleColorBuffer = getVertexBufferWithVertices(colorsTriangle);
            triangleIndexBuffer = getIndexBufferWithIndices(indicesTriangle);



            // POS X Y Z
            verticesSquareCanevas.push(-1.0, 1.0, 0.0);
            verticesSquareCanevas.push(-1.0, -1.0, 0.0);
            verticesSquareCanevas.push(1.0, 1.0, 0.0);
            verticesSquareCanevas.push(1.0, -1.0, 0.0);

            // color R G B TRANSPARENCE
            colorsSquareCanevas.push(0.0, 1.0, 1.0, 1.0);
            colorsSquareCanevas.push(1.0, 0.0, 1.0, 1.0);
            colorsSquareCanevas.push(1.0, 1.0, 0.0, 1.0);
            colorsSquareCanevas.push(1.0, 1.0, 1.0, 1.0);

            indicesSquareCanevas.push(0, 1, 2, 3);

            squareVertexBuffer = getVertexBufferWithVertices(verticesSquareCanevas);
            squareColorBuffer = getVertexBufferWithVertices(colorsSquareCanevas);
            squareIndexBuffer = getIndexBufferWithIndices(indicesSquareCanevas);

        }
        function drawScene() {


            // ******************************************************************************************
            // *****                                                                                *****
            // *****               DESSINE SUR LE PREMIER FRAME BUFFER ( TRIANGLE N ET B )          *****
            // *****                                                                                *****
            // ******************************************************************************************

            // etablie le frameBUFFER

            glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFrameBufferTab[0]);

            // clear le buffer
            glContext.viewport(0, 0, rttFrameBufferTab[0].width, rttFrameBufferTab[0].height);
            glContext.enable(glContext.DEPTH_TEST);
            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);

            mat4.identity(pMatrix);
            mat4.identity(mvMatrix);

            // déssine le triangle
            glContext.uniform1i(prg.samplerNumberUniform, 0);
            glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
            glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, triangleVertexBuffer);
            glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, triangleColorBuffer);
            glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, triangleIndexBuffer);

            glContext.activeTexture(glContext.TEXTURE0);
            glContext.bindTexture(glContext.TEXTURE_2D, null);
            // type du graphique
            glContext.drawElements(glContext.TRIANGLES, indicesTriangle.length, glContext.UNSIGNED_SHORT, 0);

            glContext.bindTexture(glContext.TEXTURE_2D, rttTextureTab[0]);
            glContext.generateMipmap(glContext.TEXTURE_2D);
            glContext.bindTexture(glContext.TEXTURE_2D, null);

            // mis en place du buffer frame
            glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);


            // ******************************************************************************************
            // *****                                                                                *****
            // *****               DESSINE SUR LE SECOND FRAME BUFFER ( TRIANGLE BLEUTER )          *****
            // *****                                                                                *****
            // ******************************************************************************************

            glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFrameBufferTab[1]);

            // clear le buffer
            glContext.viewport(0, 0, rttFrameBufferTab[1].width, rttFrameBufferTab[1].height);
            glContext.enable(glContext.DEPTH_TEST);
            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);

            mat4.identity(pMatrix);
            mat4.identity(mvMatrix);

            glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);
            glContext.uniform1i(prg.samplerNumberUniform, 1);

            glContext.activeTexture(glContext.TEXTURE0);
            glContext.bindTexture(glContext.TEXTURE_2D, rttTextureTab[0]);
            glContext.uniform1i(prg.samplerUniform, 0);

            glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
            glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, squareVertexBuffer);
            glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, squareColorBuffer);
            glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

            // type du graphique
            glContext.drawElements(glContext.TRIANGLE_STRIP, indicesSquareCanevas.length, glContext.UNSIGNED_SHORT, 0);

            glContext.bindTexture(glContext.TEXTURE_2D, rttTextureTab[1]);
            glContext.generateMipmap(glContext.TEXTURE_2D);
            glContext.bindTexture(glContext.TEXTURE_2D, null);

            // mis en place du buffer frame
            glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);

            //------------------------ fin du deuxieme framebuffer ------------------------------------

            // ******************************************************************************************
            // *****                                                                                *****
            // *****                        DESSINE SUR LE CANEVAS ( IMAGE DE FOND )                *****
            // *****                                                                                *****
            // ******************************************************************************************

            glContext.enable(glContext.DEPTH_TEST);
            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
            glContext.viewport(0, 0, c_width, c_height);

            // dessine le caré
            mat4.identity(pMatrix);
            mat4.identity(mvMatrix);


            glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);
            glContext.uniform1i(prg.samplerNumberUniform, 2);


            glContext.activeTexture(glContext.TEXTURE0);
            glContext.bindTexture(glContext.TEXTURE_2D, rttTextureTab[1]);
            glContext.uniform1i(prg.samplerUniform, 0);

            glContext.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
            glContext.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, squareVertexBuffer);
            glContext.vertexAttribPointer(prg.vertexPositionAttribute, 3, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, squareColorBuffer);
            glContext.vertexAttribPointer(prg.colorAttribute, 4, glContext.FLOAT, false, 0, 0);

            // type du graphique
            glContext.drawElements(glContext.TRIANGLE_STRIP, indicesSquareCanevas.length, glContext.UNSIGNED_SHORT, 0);

        }
        function initWebGL() {
            glContext = getGLContext('webgl-canvas');
            glContext.clearColor(0.9, 0.9, 0.9, 1.0);
            initProgram();
            initTextureFramebufferTab();
            initBuffers();
            renderLoop();
        }
    </script>
    <title>Un simple triangle</title></head>
<body onload="initWebGL()">
<script>
</script>
<header>
    <h1>Un simple triangle<br></h1>
    <br>&nbsp;&nbsp;<a href="http://webgl3d.info/" style="text-decoration:none; color: white;">WebGL par la pratique©
    2015</a></header>
<br>
Un simple triangle.
<br>
<canvas id="webgl-canvas" width="500" height="500">
    HTML5 is not supported
</canvas>

</body>
</html>