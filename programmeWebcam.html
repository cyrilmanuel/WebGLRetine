<!DOCTYPE html>
<!-- saved from url=(0052)http://webgl3d.info/ex/ch03_eg01_SingleTriangle.html -->
<html lang="fr">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <link rel="stylesheet" href="fileOther/stylesheet.css">
    <script src="fileOther/commonFunctions.js">
    </script>
    <script src="fileOther/gl-matrix-min.js">
    </script>
    <script src="fileOther/webglTools.js">
    </script>

    <style>
        #container {
            margin: 0px auto;
            width: 512px;
            height: 512px;
            border: 10px #333 solid;
        }
        #videoElement {
            width: 512px;
            height: 512px;
            background-color: #666;
        }
    </style>
    <script>
        /***************************************************************************************************************
         *      shader for the first rendering     *
         **************************************************************************************************************/
    </script>
    <script id="shader-vs-0" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aColor;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec4 vColor;
        void main(void) {
          vColor = aColor;
          gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>
    <script id="shader-fs-0" type="x-shader/x-fragment">
        #ifdef GL_ES
          precision highp float;
        #endif
        varying vec4 vColor;
        void main(void) {
           gl_FragColor = vColor;
        }
    </script>

   <script>
        /***************************************************************************************************************
         *      shader for the RenderTexture      *
         **************************************************************************************************************/
    </script>
    <script id="shader-vs-Render" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aColor;
        attribute vec2 textCoord;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;
        varying vec4 vColor;
        varying vec2 vTexCoord;
        void main(void) {
          vColor = aColor;
          vTexCoord = textCoord;
          gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>
    <script id="shader-fs-Render" type="x-shader/x-fragment">
       #ifdef GL_ES
          precision highp float;
        #endif
        varying vec4 vColor;
        uniform sampler2D uSampler;
        varying vec2 vTexCoord;
        void main(void) {
            vec4 color = texture2D(uSampler, vTexCoord);
            gl_FragColor = color;
        }
    </script>
    <script>

        // dessin des triangles
        var triangleVertexBuffer = null;
        var triangleIndexBuffer = null;
        var triangleColorBuffer = null;

        var indicesTriangle = [];
        var verticesTriangle = [];
        var colorsTriangle = [];

        // dessin du carré pour le rendu. carré qui prend le canevas (rendu final)
        var squareVertexBuffer = null;
        var squareIndexBuffer = null;
        var squareColorBuffer = null;

        var indicesSquareCanevas = [];
        var verticesSquareCanevas = [];
        var colorsSquareCanevas = [];

        var	textCoords = new Array();
        var textureBuffersArray = [];


        var mvMatrix = mat4.create();
        var pMatrix = mat4.create();

        var rttFrameBufferTab = [];
        var rttTextureTab = [];
        var nombreFrameBuffer = 3;

        var videoElement;
        var videoTexture;


        var progList = [];
        var ptr = new Object();

        function initCamera() {
            mat4.identity(mvMatrix);
            mat4.perspective(pMatrix, degToRad(45.0), c_width / c_height, 0.1, 1000.0);
        }

        function initShaders() {

            /*******************************************
             * Inits the shader for the first rendering
             *******************************************/
                    //Selection of the 2 shader texts for the first rendering (webcam)
            var vertexShader0 = getTextContent("shader-vs-0");
            var fragmentShader0 = getTextContent("shader-fs-0");
            //Create the program for the shader
            progList[0] = createProgram(glContext, vertexShader0, fragmentShader0);

            /*******************************************
             * Inits the shader for the rendering
             *******************************************/
            var vertexShaderSceneRender = getTextContent("shader-vs-Render");
            var fragmentShaderSceneRender = getTextContent("shader-fs-Render");
            progList[10] = createProgram(glContext, vertexShaderSceneRender, fragmentShaderSceneRender);


            initShaderParameters();

            //We define the planet progam as the current program
            glContext.useProgram(progList[0]);

        }

        function initShaderParameters() {

            /*******************************************
             * Inits the pointers for the first rendering drawForm
             *******************************************/
            ptr.vertexPositionAttribute0 = glContext.getAttribLocation(progList[0], "aVertexPosition");
            glContext.enableVertexAttribArray(ptr.vertexPositionAttribute0);
            ptr.colorAttribute0 = glContext.getAttribLocation(progList[0], "aColor");
            glContext.enableVertexAttribArray(ptr.colorAttribute0);
            ptr.pMatrixUniform0 = glContext.getUniformLocation(progList[0], 'uPMatrix');
            ptr.mvMatrixUniform0 = glContext.getUniformLocation(progList[0], 'uMVMatrix');

            /*******************************************
             * Inits the pointers for the rendering programme
             *******************************************/

            ptr.vertexPositionAttributeRender = glContext.getAttribLocation(progList[10], "aVertexPosition");
            glContext.enableVertexAttribArray(ptr.vertexPositionAttributeRender);
            ptr.colorAttributeRender = glContext.getAttribLocation(progList[10], "aColor");
            glContext.enableVertexAttribArray(ptr.colorAttributeRender);
            ptr.textureCoordsAttributeRender = glContext.getAttribLocation(progList[10], "textCoord");
            glContext.enableVertexAttribArray(ptr.textureCoordsAttributeRender);
            ptr.pMatrixUniformRender = glContext.getUniformLocation(progList[10], 'uPMatrix');
            ptr.mvMatrixUniformRender = glContext.getUniformLocation(progList[10], 'uMVMatrix');
            ptr.samplerUniformRender = glContext.getUniformLocation(progList[10], "uSampler");

        }

        function initTextureFramebufferTab() {
            for (i = 0; i < nombreFrameBuffer; i++) {
                rttFrameBufferTab[i] = glContext.createFramebuffer();
                glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFrameBufferTab[i]);
                rttFrameBufferTab[i].width = 512;
                rttFrameBufferTab[i].height = 512;
                // espace pour la texture sur la cg (WEBTOOL textureWithImage)
                rttTextureTab[i] = glContext.createTexture();
                glContext.bindTexture(glContext.TEXTURE_2D, rttTextureTab[i]);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.LINEAR);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.LINEAR_MIPMAP_NEAREST);
                //glContext.generateMipmap(glContext.TEXTURE_2D);
                glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, rttFrameBufferTab[i].width, rttFrameBufferTab[i].height, 0, glContext.RGBA, glContext.UNSIGNED_BYTE, null);
                // mtn on a préparer un espace pour la texture qui est vide et de taille du rttFramebuffer. contiendra pour les couleurs, le canevas.
                // on va  définir le buffer de rendu
                var renderbuffer = glContext.createRenderbuffer();
                glContext.bindRenderbuffer(glContext.RENDERBUFFER, renderbuffer);
                glContext.renderbufferStorage(glContext.RENDERBUFFER, glContext.DEPTH_COMPONENT16, rttFrameBufferTab[i].width, rttFrameBufferTab[i].height);
                /*
                 * Nous attachons tout à la framebuffer actuelle (rappelez-vous, nous avons lié notre nouveau pour être le courant juste après sa création en haut de la fonction).
                 * Nous lui disons que l'espace du framebuffer pour les couleurs de rendu ( gl.COLOR_ATTACHMENT0 ) est notre texture, et que la mémoire qu'il doit utiliser pour
                 * obtenir des informations de profondeur ( gl.DEPTH_ATTACHMENT ) est le tampon de profondeur que nous venons de créer.
                 * */
                glContext.framebufferTexture2D(glContext.FRAMEBUFFER, glContext.COLOR_ATTACHMENT0, glContext.TEXTURE_2D, rttTextureTab[i], 0);
                glContext.framebufferRenderbuffer(glContext.FRAMEBUFFER, glContext.DEPTH_ATTACHMENT, glContext.RENDERBUFFER, renderbuffer);
                /*
                 * maintenant que tout est correctement créer est binder, on les remets a 0
                 * */
                glContext.bindTexture(glContext.TEXTURE_2D, null);
                glContext.bindRenderbuffer(glContext.RENDERBUFFER, null);
                glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);
            }

        }


        function initBuffers() {


            // partie pour les triangles de base

            // POS X Y Z
            verticesTriangle.push(-1.0, -1.0, 0.0);
            verticesTriangle.push(1.0, -1.0, 0.0);
            verticesTriangle.push(0.0, 1.0, 0.0);

            verticesTriangle.push(-1, 1.0, 0.0);
            verticesTriangle.push(1.0, 1.0, 0.0);
            verticesTriangle.push(0.0, -1.0, 0.0);


            // color R G B TRANSPARENCE
            colorsTriangle.push(0.0, 0.0, 0.0, 1.0);
            colorsTriangle.push(0.0, 0.0, 0.0, 1.0);
            colorsTriangle.push(0.0, 0.0, 0.0, 1.0);


            colorsTriangle.push(1.0, 1.0, 1.0, 1.0);
            colorsTriangle.push(1.0, 1.0, 1.0, 1.0);
            colorsTriangle.push(1.0, 1.0, 1.0, 1.0);

            indicesTriangle.push(0, 1, 2);
            indicesTriangle.push(3, 4, 5);


            triangleVertexBuffer = getVertexBufferWithVertices(verticesTriangle);
            triangleColorBuffer = getVertexBufferWithVertices(colorsTriangle);
            triangleIndexBuffer = getIndexBufferWithIndices(indicesTriangle);


            // POS X Y Z
            verticesSquareCanevas.push(-1.0, 1.0, 0.1);
            verticesSquareCanevas.push(-1.0, -1.0, 0.1);
            verticesSquareCanevas.push(1.0, 1.0, 0.1);
            verticesSquareCanevas.push(1.0, -1.0, 0.1);


            // color R G B TRANSPARENCE
            colorsSquareCanevas.push(1.0, 1.0, 1.0, 1.0);
            colorsSquareCanevas.push(1.0, 1.0, 1.0, 1.0);
            colorsSquareCanevas.push(1.0, 1.0, 1.0, 1.0);
            colorsSquareCanevas.push(1.0, 1.0, 1.0, 1.0);

            indicesSquareCanevas.push(0, 1, 2, 3);

            squareVertexBuffer = getVertexBufferWithVertices(verticesSquareCanevas);
            squareColorBuffer = getVertexBufferWithVertices(colorsSquareCanevas);
            squareIndexBuffer = getIndexBufferWithIndices(indicesSquareCanevas);

            textCoords = [
                1, 1,
                1, 0,
                0, 1,
                0, 0,
               ];
            textureBuffersArray = getArrayBufferWithArray(textCoords);

        }
        function initTexture()
        {
            videoTexture = glContext.createTexture();

            videoTexture.image = new Image();
            videoTexture.image.onload = function()
            {
                handleLoadedTexture(videoTexture)
            }
            videoTexture.image.src = video.src;
        }

        function handleLoadedTexture(texture)
        {
            try
            {
                glContext.pixelStorei(glContext.UNPACK_FLIP_Y_WEBGL, true);
                glContext.bindTexture(glContext.TEXTURE_2D, texture);
                glContext.texImage2D(glContext.TEXTURE_2D, 0, glContext.RGBA, glContext.RGBA, glContext.UNSIGNED_BYTE, texture.image);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_S, glContext.CLAMP_TO_EDGE);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_WRAP_T, glContext.CLAMP_TO_EDGE);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MAG_FILTER, glContext.NEAREST);
                glContext.texParameteri(glContext.TEXTURE_2D, glContext.TEXTURE_MIN_FILTER, glContext.NEAREST);
                glContext.bindTexture(glContext.TEXTURE_2D, null);
            }
            catch (e)
            {
                console.log(e.message);
            }
        }
        function drawScene() {

            glContext.useProgram(progList[0]);
            // ******************************************************************************************
            // *****                                                                                *****
            // *****               DESSINE SUR LE PREMIER FRAME BUFFER ( TRIANGLE N ET B )          *****
            // *****                                                                                *****
            // ******************************************************************************************

            // etablie le frameBUFFER

            glContext.bindFramebuffer(glContext.FRAMEBUFFER, rttFrameBufferTab[0]);

            // clear le buffer
            glContext.viewport(0, 0, rttFrameBufferTab[0].width, rttFrameBufferTab[0].height);
            glContext.enable(glContext.DEPTH_TEST);
            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);

            mat4.identity(pMatrix);
            mat4.identity(mvMatrix);

            // déssine le triangle
            glContext.uniformMatrix4fv(ptr.pMatrixUniform0, false, pMatrix);
            glContext.uniformMatrix4fv(ptr.mvMatrixUniform0, false, mvMatrix);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, triangleVertexBuffer);
            glContext.vertexAttribPointer(ptr.vertexPositionAttribute0, 3, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, triangleColorBuffer);
            glContext.vertexAttribPointer(ptr.colorAttribute0, 4, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, triangleIndexBuffer);

            glContext.activeTexture(glContext.TEXTURE0);
            glContext.bindTexture(glContext.TEXTURE_2D, null);
            // type du graphique
            glContext.drawElements(glContext.TRIANGLES, indicesTriangle.length, glContext.UNSIGNED_SHORT, 0);

            glContext.bindTexture(glContext.TEXTURE_2D, rttTextureTab[0]);
            glContext.generateMipmap(glContext.TEXTURE_2D);
            glContext.bindTexture(glContext.TEXTURE_2D, null);

            // mis en place du buffer frame
            glContext.bindFramebuffer(glContext.FRAMEBUFFER, null);

            glContext.useProgram(progList[1]);




            //------------------------ fin du deuxieme framebuffer ------------------------------------

            // ******************************************************************************************
            // *****                                                                                *****
            // *****                        DESSINE SUR LE CANEVAS ( IMAGE DE FOND )                *****
            // *****                                                                                *****
            // ******************************************************************************************

            glContext.useProgram(progList[10]);

            glContext.enable(glContext.DEPTH_TEST);
            glContext.clear(glContext.COLOR_BUFFER_BIT | glContext.DEPTH_BUFFER_BIT);
            glContext.viewport(0, 0, c_width, c_height);

            // dessine le caré
            mat4.identity(pMatrix);
            mat4.identity(mvMatrix);

            glContext.bindBuffer(glContext.ELEMENT_ARRAY_BUFFER, squareIndexBuffer);
            glContext.activeTexture(glContext.TEXTURE0);
            glContext.bindTexture(glContext.TEXTURE_2D, videoTexture);
            glContext.uniform1i(ptr.samplerUniformRender, 0);

            glContext.uniformMatrix4fv(ptr.pMatrixUniformRender, false, pMatrix);
            glContext.uniformMatrix4fv(ptr.mvMatrixUniformRender, false, mvMatrix);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, squareVertexBuffer);
            glContext.vertexAttribPointer(ptr.vertexPositionAttributeRender, 3, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, squareColorBuffer);
            glContext.vertexAttribPointer(ptr.colorAttributeRender, 4, glContext.FLOAT, false, 0, 0);
            glContext.bindBuffer(glContext.ARRAY_BUFFER, textureBuffersArray);
            glContext.vertexAttribPointer(ptr.textureCoordsAttributeRender, 2, glContext.FLOAT, false, 0, 0);

            // type du graphique
            glContext.drawElements(glContext.TRIANGLE_STRIP, indicesSquareCanevas.length, glContext.UNSIGNED_SHORT, 0);

        }
        function initWebGL() {
            glContext = getGLContext('webgl-canvas');
            glContext.clearColor(0.9, 0.9, 0.9, 1.0);
            //  initProgram();
            initShaders();
            initCamera();
            initTextureFramebufferTab();
            initBuffers();
            initTexture();
            renderLoop();
        }
    </script>
    <title>Un simple triangle</title></head>
<body onload="initWebGL()">
<script>
</script>
<header>
    <h1>Un simple triangle<br></h1>
    <br>&nbsp;&nbsp;<a href="http://webgl3d.info/" style="text-decoration:none; color: white;">WebGL par la pratique©
    2015</a></header>
<br>
Un simple triangle.
<br>
<canvas id="webgl-canvas" width="500" height="500">
    HTML5 is not supported
</canvas>
<div id="container">
    <video autoplay="true" id="videoElement">

    </video>
</div>
<script>
    var video = document.querySelector("#videoElement");

    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

    if (navigator.getUserMedia) {
        navigator.getUserMedia({video: true}, handleVideo, videoError);
    }

    function handleVideo(stream) {
        video.src = window.URL.createObjectURL(stream);
    }

    function videoError(e) {
        // do something
    }
</script>

</body>
</html>